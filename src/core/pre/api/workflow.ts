/**
 *  Encapsulate the entire pre file sharing process
 * Note: Anything with an Account parameter is placed in the first parameter of the function. It is convenient to unify the calling format when interacting with the browser page
 */
import sleep from "await-sleep";
import { signMessage } from "../../utils/signMessage";

import { Account, Strategy, web3 } from "../../hdwallet/api/account";

// notice: bacause the MessageKit use the SecretKey import from nucypher-ts, so you  must be use the nucypher-ts's SecretKey PublicKey , not use the nucypher-core's SecretKey PublicKey (wasm code) to avoid the nucypher_core_wasm_bg.js Error: expected instance of e
import {
  Alice,
  BlockchainPolicyParameters,
  EnactedPolicy,
  MessageKit,
  RemoteBob,
} from "@nulink_network/nulink-ts";

import { EncryptedTreasureMap, HRAC } from "@nucypher/nucypher-core";

//reference: https://github.com/nucypher/nucypher-ts-demo/blob/main/src/characters.ts
// notice: bacause the encryptedMessage.decrypt( get by MessageKit) use the SecretKey import from nucypher-ts, so you  must be use the nucypher-ts's SecretKey PublicKey , not use the nucypher-core's SecretKey PublicKey (wasm code) to avoid the nucypher_core_wasm_bg.js Error: expected instance of e
import {
  PublicKey,
  SecretKey as NucypherTsSecretKey,
} from "@nulink_network/nulink-ts";

import { encryptMessage } from "./enrico";
import { isBlank } from "../../utils/null";
import { FileCategory, FileInfo, FileType } from "../types";
import assert from "assert-ts";
import { getSettingsData } from "../../chainnet";
import { serverGet, serverPost } from "../../servernet";
import { nanoid } from "nanoid";
import { Bob, makeBob, makeRemoteBob } from "./bob";
import {
  Porter,
  Ursula,
} from "@nulink_network/nulink-ts/build/main/src/characters/porter";
import {
  BlockchainPolicy,
  createChainPolicy,
  makeAlice,
  getBalance,
  getUrsulas,
  approveNLK,
  estimateApproveNLKGas,
} from "./alice";

import { BigNumber } from "ethers";
import { ethers } from "ethers";
import { SubscriptionManagerAgent } from "@nulink_network/nulink-ts/build/main/src/agents/subscription-manager";
import { toEpoch } from "../../utils/format";
import {
  compressPublicKeyBuffer,
  compressPublicKeyBuffer2,
  privateKeyBuffer,
} from "../../hdwallet/api/common";
import { getPorterUrl } from "./porter";
import { setData as setIPFSData, getData as getIPFSData } from "../../utils/ipfs";
import humps from "humps";
import { getBlurThumbnail } from "../../utils/image";
import { ThumbailResult } from "../../utils/image";
import md5 from "md5";
import { fileSuffix } from "../../utils/file";
import Web3 from "web3";
import { fromBytes, fromBytesByEncoding } from "../../utils/encode";
import { decrypt as pwdDecrypt } from "../../utils/passwordEncryption";
import {
  getUrsulaError,
  InsufficientBalanceError,
  PolicyHasBeenActivedOnChain,
} from "../../utils/exception";
import { getWeb3 } from "../../hdwallet/api";

/**
 * @internal
 */
export const getServerTimeStamp = async (): Promise<string> => {
  //get golbal time from server
  const sendData = {};

  const data = (await serverGet("/timestamp", sendData)) as object;

  return data["timestamp"] as string;
};

export const signUpdateServerDataMessage = async (
  account: Account,
  data: "dataDict"
) => {
  // Do not use local time. Gets UTC real time in milliseconds with 0.001 precision from http://worldtimeapi.org/api/timezone/Etc/UTC.
  //data["timestamp"] = (new Date().getTime() / 1000) | 0; // Discard the decimal number
  //UTC real time
  data["timestamp"] = await getServerTimeStamp();

  return await signMessage(
    data,
    pwdDecrypt(account.encryptedKeyPair._privateKey, true)
  );
};

export const createAccountIfNotExist = async (account: Account) => {
  const exist: boolean = await IsExistAccount(account);
  if (!exist) {
    await createAccount(account);
  }
};

export const IsExistAccount = async (account: Account): Promise<boolean> => {
  /*
Determine if the account exists
*/
  // if success return {}

  const sendData = {
    // name: account.name,
    account_id: account.id,
    // ethereum_addr: account.address,
    // encrypted_pk: account.encryptedKeyPair._publicKey,
    // verify_pk: account.encryptedKeyPair._publicKey, //account.verifyKeyPair._publicKey, //Adapter code for nucypher-ts  Note Bob, Enrico's Encrypted PK SK is the same as Verify PK SK.  Alice verify PK can use encrypted PK.  In Nucypher-TS, Alice encryption key uses the public and private key pair generated by label, which is the policy public key for us.
  };

  const data = (await serverPost("/account/isexist", sendData)) as object;

  return data["is_exist"] as boolean;
};

export const createAccount = async (account: Account) => {
  /*
https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7
*/
  // if success return {}

  const sendData = {
    name: account.name,
    account_id: account.id,
    ethereum_addr: account.address,
    encrypted_pk: account.encryptedKeyPair._publicKey,
    verify_pk: account.encryptedKeyPair._publicKey, //account.verifyKeyPair._publicKey, //Adapter code for nucypher-ts   Note Bob, Enrico's Encrypted PK SK is the same as Verify PK SK.  Alice verify PK can use encrypted PK.  In Nucypher-TS, Alice encryption key uses the public and private key pair generated by label, which is the policy public key for us.
  };

  const data = await serverPost("/account/create", sendData);

  return data;
};

export const getAccountInfo = async (accountId: string) => {
  /*
    https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF

    
     if success  return {
      name	string	account name
      account_id	string	account ID(UUID v4)
      ethereum_addr	string	eth address
      encrypted_pk	string	encrypted PK
      verify_pk	string	verifyed PK
      status	number	account state
      created_at	number	account create time
      avatar           string  IPFS address of avatar
      name         string  nickname            
      user_site         string  Address of the user's primary site   
      twitter          string  twitter address     
      instagram        string  instagram address  
      facebook         string  facebook address    
      profile string  personal data        
    }
*/

  const sendData = {
    account_id: accountId,
  };

  const data = await serverPost("/account/get", sendData);

  return data;
};

export const updateAccountInfo = async (
  account: Account,
  updateData: Record<string, string>
) => {
  const sendData: any = {
    account_id: account.id,
  };

  if (Object.prototype.hasOwnProperty.call(updateData, "avatar") && !!updateData["avatar"]) {
    sendData["avatar"] = updateData["avatar"];
  }

  if (Object.prototype.hasOwnProperty.call(updateData, "nickname") && !!updateData["nickname"]) {
    sendData["name"] = updateData["nickname"];

    account.name = updateData["nickname"];

    //Store account meta information in a decentralized manner
    await account.saveAccountItselfInfo();
  }

  if (Object.prototype.hasOwnProperty.call(updateData, "userSite")) {
    sendData["user_site"] = updateData["userSite"];
  }

  if (Object.prototype.hasOwnProperty.call(updateData, "twitter")) {
    sendData["twitter"] = updateData["twitter"];
  }

  if (Object.prototype.hasOwnProperty.call(updateData, "instagram")) {
    sendData["instagram"] = updateData["instagram"];
  }

  if (Object.prototype.hasOwnProperty.call(updateData, "facebook")) {
    sendData["facebook"] = updateData["facebook"];
  }

  if (Object.prototype.hasOwnProperty.call(updateData, "personalProfile")) {
    sendData["profile"] = updateData["personalProfile"];
  }

  sendData["signature"] = await signUpdateServerDataMessage(account, sendData);

  const data = await serverPost("/account/update", sendData);

  return data;
};
/*
//The currently designed page calls the plugin logic
//Click the button on the page: pass in the parameters and function name (or message name), call the plug-in authorization, the user clicks OK, the plug-in obtains the default account, splices the parameters and calls the incoming function, and calls the page function after completion, or sends a message to tell the calling interface As a result, the page performs the next action.
return the strategy info
*/

export const uploadFilesByCreatePolicy = async (
  account: Account,
  fileCategory: FileCategory | string, //File category, according to the design: only one category is allowed to be uploaded in batches, and different categories need to be uploaded separately
  fileList: FileInfo[] //file information list
): Promise<Strategy> => {
  console.log("uploadFilesByCreatePolicy account", account);

  let label = "";
  if (typeof fileCategory == "number") {
    //e.g. FileCategory.Philosophy => typeof FileCategory.Philosophy == "number"

    if (typeof FileCategory[fileCategory.toString()] == "undefined") {
      label = fileCategory.toString();
    } else {
      label = FileCategory[fileCategory.toString()];
    }
  } else {
    //typeof fileCategory == "string"
    label = fileCategory as string;
  }

  if (!label) {
    label = "";
  }

  // Number.isNaN(parseInt("Philosophy"))
  const strategy: Strategy = await account.createStrategyByLabel(label);
  // console.log("uploadFilesByCreatePolicy strategy", strategy);

  //TODO: call server interface Check whether the file needs to be uploaded repeatedly
  // console.log("uploadFilesByCreatePolicy fileList", fileList);
  /*   //for test start
  const plainText = "This is a history book content";
  const enc = new TextEncoder(); // always utf-8
  const historyContent: Uint8Array = enc.encode(plainText);

  fileList = [{ name: `history-${nanoid()}.pdf`, fileBinaryArrayBuffer: historyContent.buffer }];
  //for test end */

  const fileContentList: ArrayBuffer[] = [];
  for (const fileInfo of fileList) {
    fileContentList.push(fileInfo.fileBinaryArrayBuffer);
  }
  // console.log("uploadFilesByCreatePolicy fileContentList", fileContentList);

  const _encryptMessages: MessageKit[] = encryptMessage(
    strategy.strategyKeyPair._publicKey,
    fileContentList
  );
  // console.log("uploadFilesByCreatePolicy _encryptMessages", _encryptMessages);
  const mockIPFSAddressList: string[] = [];
  for (const _encryptMessage of _encryptMessages) {
    const _encryptMessageBytes: Uint8Array = _encryptMessage.toBytes();
    //upload encrypt files to IPFS
    const cid = await setIPFSData(_encryptMessageBytes);
    mockIPFSAddressList.push(cid);
  }
  // console.log("uploadFilesByCreatePolicy mockIPFSAddressList", mockIPFSAddressList);
  const fileInfos: object[] = [];
  for (let index = 0; index < fileList.length; index++) {
    const fileInfo = fileList[index];

    const fileId = nanoid();

    //generate and upload thumbnail files to IPFS
    let thumbnail = "";
    try {
      const result = await getBlurThumbnail(
        fileInfo.fileBinaryArrayBuffer,
        fileInfo.name
      );
      if (isBlank(result)) {
        thumbnail = "";
      } else {
        const { buffer: thumbnailBuffer, mimeType }: ThumbailResult =
          result as ThumbailResult;
        thumbnail =
          mimeType + "|" + (await setIPFSData(thumbnailBuffer.buffer));
      }
    } catch (error) {
      thumbnail = "";
      console.error(
        `generate or upload thumbail failed file name: ${fileInfo.name}, file id:${fileId}`,
        error
      );
    }

    const file = {
      id: fileId,
      name: fileInfo.name,
      address: mockIPFSAddressList[index],
      md5: md5(new Uint8Array(fileInfo.fileBinaryArrayBuffer), {
        encoding: "binary",
      }),
      suffix: fileSuffix(fileInfo.name),
      category: label,
      thumbnail: thumbnail || "",
    };
    fileInfos.push(file);
  }
  // console.log("uploadFilesByCreatePolicy fileInfos", fileInfos);
  try {
    const sendData: any = {
      files: fileInfos,
      account_id: account.id,
      policy_label_id: strategy.id,
      policy_label: strategy.label,
      policy_label_index: String(strategy.addressIndex),
      encrypted_pk: strategy.strategyKeyPair._publicKey,
    };

    sendData["signature"] = await signUpdateServerDataMessage(
      account,
      sendData
    );

    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const data = await serverPost("/file/create-policy-and-upload", sendData);
  } catch (error) {
    // Message.error("upload file failed!");
    console.error("upload file failed!: ", error);

    // clear this failed strategy info
    await account.deleteStrategy(strategy.addressIndex);
    throw error;
  }

  // console.log("uploadFilesByCreatePolicy after serverPost", data);
  return strategy;
};

export const uploadFilesBySelectPolicy = async (
  account: Account,
  fileCategory: FileCategory | string, //File category, according to the design: only one category is allowed to be uploaded in batches, and different categories need to be uploaded separately
  fileList: FileInfo[], //file information list
  policyId: number // policy info id
): Promise<string[]> => {
  //TODO: call server interface Check whether the file needs to be uploaded repeatedly
  //return file id array

  let label = "";
  if (typeof fileCategory == "number") {
    //e.g. FileCategory.Philosophy => typeof FileCategory.Philosophy == "number"

    if (typeof FileCategory[fileCategory.toString()] == "undefined") {
      label = fileCategory.toString();
    } else {
      label = FileCategory[fileCategory.toString()];
    }
  } else {
    //typeof fileCategory == "string"
    label = fileCategory as string;
  }

  const fileContentList: ArrayBuffer[] = [];
  for (const fileInfo of fileList) {
    fileContentList.push(fileInfo.fileBinaryArrayBuffer);
  }

  //Get poliy info by policy Id
  const policyInfo = (await getPoliciesInfo(policyId)) as object;
  assert(policyInfo && !isBlank(policyInfo) && policyInfo["total"] > 0);
  const policyEncrypedPublicKey = policyInfo["list"][0]["encrypted_pk"];

  const _encryptMessages: MessageKit[] = encryptMessage(
    policyEncrypedPublicKey,
    fileContentList
  );

  const mockIPFSAddressList: string[] = [];
  for (const _encryptMessage of _encryptMessages) {
    const _encryptMessageBytes: Uint8Array = _encryptMessage.toBytes();
    //upload encrypt files to IPFS
    const cid = await setIPFSData(_encryptMessageBytes);
    mockIPFSAddressList.push(cid);
  }

  const retInfo: string[] = [];
  const fileInfos: object[] = [];
  for (let index = 0; index < fileList.length; index++) {
    const fileInfo = fileList[index];
    const fileId = nanoid();

    //generate and upload thumbnail files to IPFS
    let thumbnail = "";
    try {
      const result = await getBlurThumbnail(
        fileInfo.fileBinaryArrayBuffer,
        fileInfo.name
      );
      if (isBlank(result)) {
        thumbnail = "";
      } else {
        const { buffer: thumbnailBuffer, mimeType }: ThumbailResult =
          result as ThumbailResult;
        thumbnail =
          mimeType + "|" + (await setIPFSData(thumbnailBuffer.buffer));
      }
    } catch (error) {
      thumbnail = "";
      console.error(
        `generate or upload thumbail failed file name: ${fileInfo.name}, file id:${fileId}`,
        error
      );
    }

    const file = {
      id: fileId,
      name: fileInfo.name,
      address: mockIPFSAddressList[index],
      md5: md5(new Uint8Array(fileInfo.fileBinaryArrayBuffer), {
        encoding: "binary",
      }),
      suffix: fileSuffix(fileInfo.name),
      category: label,
      thumbnail: thumbnail || "",
    };

    fileInfos.push(file);
    retInfo.push(file.id);
  }

  const sendData: any = {
    files: fileInfos,
    account_id: account.id,
    policy_id: policyId,
  };

  sendData["signature"] = await signUpdateServerDataMessage(account, sendData);

  //Select an existing policy
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const data = await serverPost("/file/upload", sendData);

  return retInfo;
};

export const getUploadedFiles = async (
  account: Account,
  fileName?: string,
  pageIndex = 1,
  pageSize = 10
) => {
  return await getFileInfosByAccount(account, fileName, pageIndex, pageSize);
};

// Gets or search a list of upload files for the account, This account acts as the publisher => Get the Files uploaded by the account itself
export const getFileInfosByAccount = async (
  account: Account,
  fileName?: string,
  pageIndex = 1,
  pageSize = 10
) => {
  //file_name support fuzzy query

  /*
https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8
return data format: {
  list: [
    {file_id, file_name:, owner, owner_id, address:,thumbnail:,create_at}
    ...
  ],
  total: 300,
}
*/

  const sendData = {
    account_id: account.id,
    paginate: {
      page: pageIndex,
      page_size: pageSize,
    },
  };

  if (!isBlank(fileName)) {
    sendData["file_name"] = fileName;
  }

  const data = await serverPost("/file/list", sendData);

  return data;
};

// Delete the uploaded files for the account, This account acts as the publisher
export const deleteUploadedFiles = async (
  account: Account,
  fileIds: string[]
) => {
  /*
  https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6
  return the list of deleted files is displayed: [
      {"file_id": "", "file_name": ""},
      ...
    ]
  */

  const sendData: any = {
    account_id: account.id,
    file_ids: fileIds,
  };

  sendData["signature"] = await signUpdateServerDataMessage(account, sendData);

  const data = await serverPost("/file/delete", sendData);

  return data;
};

//Gets a list of files shared by others (Files uploaded by yourself are not included), This account acts as the user
export const getOtherShareFiles = async (
  account: Account, // current account info
  fileName?: string,
  include?: boolean, //indicates whether the query result contains file list data of the current account
  fileCategory?: FileCategory | string,
  fileType?: FileType,
  descOrder = true, //Whether to sort by upload time in reverse order
  pageIndex = 1,
  pageSize = 10
) => {
  //file_name support fuzzy query

  /*
https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E5%85%B6%E4%BB%96%E4%BA%BA%E7%9A%84%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8
return data format: {
  list: [
    {file_id, file_name:, owner, owner_id, address:,thumbnail:,create_at}
    ...
  ],
  total: 300,
}
*/

  const sendData = {
    account_id: account.id,
    desc: descOrder,
    paginate: {
      page: pageIndex,
      page_size: pageSize,
    },
  };

  sendData["include"] = !!include;

  if (!isBlank(fileName)) {
    sendData["file_name"] = fileName;
  }

  if (!isBlank(fileCategory)) {
    sendData["category"] =
      FileCategory[(fileCategory as FileCategory).toString()] ||
      (fileCategory as string);
  }

  if (!isBlank(fileType)) {
    sendData["format"] = FileType[(fileType as FileType).toString()];
  }

  const data = await serverPost("/file/others-list", sendData);

  return data;
};

//The user applies for permission to use the file.
export const applyForFilesUsagePermission = async (
  fileIds: string[],
  account: Account,
  usageDays = 7
) => {
  /*
  //TODO:  Consider returning the apply record ID
https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E7%94%B3%E8%AF%B7%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8
return data format: {}
*/
  if (usageDays <= 0) {
    throw Error(
      "The application file's validity period must be greater than 0 days"
    );
  }

  const sendData: any = {
    file_ids: fileIds,
    proposer_id: account.id,
    account_id: account.id, //new for backend signature
    days: usageDays,
  };
  /*   console.log(
    `usageDays: ${usageDays}, startMs: ${startMs}, endMs: ${endMs}, endMs-startMs:${
      (endMs - startMs) / (1000.0 * 60 * 60 * 24)
    }`,
  ); */

  // console.log("apply file user account", account);
  // console.log("apply file file_ids", fileIds);

  sendData["signature"] = await signUpdateServerDataMessage(account, sendData);

  const data = await serverPost("/apply/file", sendData);

  return data;
};


//Cancellation of application for use of documents, This account acts as the user (Bob)
//If it has been approved or failed, it can not be revoked
export const revokePermissionApplicationOfFiles = async (
  account: Account, //Bob
  applyIds: number[] //Application Record ID
) => {
  /*
The processing logic of the background service is: multiple applications are either all successful or none successful  

https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E6%92%A4%E9%94%80%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%94%B3%E8%AF%B7
return data format: {}
*/

  const sendData: any = {
    apply_ids: applyIds,
    proposer_id: account.id,
    account_id: account.id, //new for backend signature
  };

  sendData["signature"] = await signUpdateServerDataMessage(account, sendData);

  const data = await serverPost("/apply/revoke", sendData);

  return data;
};

//get all status files as Publisher. This account acts as the publisher (Alice)
export const getFilesAllStatusAsPublisher = async (
  account: Account,
  pageIndex = 1,
  pageSize = 10
) => {
  /*return data format: {
  list: [
    { apply_id, file_id:, proposer, proposer_id, file_owner:, file_owner_id:, policy_id, hrac, start_at:, end_at, days, created_at }
    ...
  ],
  total: 300,
}
*/

  return await getFilesByStatus(
    undefined,
    undefined,
    account.id,
    undefined,
    0,
    pageIndex,
    pageSize
  );
};

export const getFilesByApplyStatusAsPublisher = async (
  account: Account,
  status = 0,
  pageIndex = 1,
  pageSize = 10
) => {
  /*return data format: {
  list: [
    { apply_id, file_id:, proposer, proposer_id, file_owner:, file_owner_id:, policy_id, hrac, start_at:, end_at, days, created_at }
    ...
  ],
  total: 300,
}
*/

  return await getFilesByStatus(
    undefined,
    undefined,
    account.id,
    undefined,
    status,
    pageIndex,
    pageSize
  );
};

//get the application status files (applying but not approved) This account acts as the publisher (Alice), need to approved
export const getFilesPendingApprovalAsPublisher = async (
  account: Account,
  pageIndex = 1,
  pageSize = 10
) => {
  /*return data format: {
  list: [
    { apply_id, file_id:, proposer, proposer_id, file_owner:, file_owner_id:, policy_id, hrac, start_at:, end_at, days, created_at }
    ...
  ],
  total: 300,
}
*/

  return await getFilesByStatus(
    undefined,
    undefined,
    account.id,
    undefined,
    1,
    pageIndex,
    pageSize
  );
};

//get the Approved success status files  for others to use. This account acts as the publisher (Alice)
export const getApprovedFilesAsPublisher = async (
  account: Account,
  pageIndex = 1,
  pageSize = 10
) => {
  /*return data format: {
  list: [
    { apply_id, file_id:, proposer, proposer_id, file_owner:, file_owner_id:, policy_id, hrac, start_at:, end_at, days, created_at }
    ...
  ],
  total: 300,
}
*/

  return await getFilesByStatus(
    undefined,
    undefined,
    account.id,
    undefined,
    2,
    pageIndex,
    pageSize
  );
};

//get the Approved failed status files for others to use. This account acts as the publisher (Alice)
export const getFilesForRefusedAsPublisher = async (
  account: Account,
  pageIndex = 1,
  pageSize = 10
) => {
  /*return data format: {
  list: [
    { apply_id, file_id:, proposer, proposer_id, file_owner:, file_owner_id:, policy_id, hrac, start_at:, end_at, days, created_at }
    ...
  ],
  total: 300,
}
*/

  return await getFilesByStatus(
    undefined,
    undefined,
    account.id,
    undefined,
    3,
    pageIndex,
    pageSize
  );
};

//get all status files as User This account acts as user (Bob)
export const getFilesAllStatusAsUser = async (
  account: Account,
  pageIndex = 1,
  pageSize = 10
) => {
  /*return data format: {
  list: [
    { apply_id, file_id:, proposer, proposer_id, file_owner:, file_owner_id:, policy_id, hrac, start_at:, end_at, days, created_at }
    ...
  ],
  total: 300,
}
*/

  return await getFilesByStatus(
    undefined,
    account.id,
    undefined,
    undefined,
    0,
    pageIndex,
    pageSize
  );
};

//get all status files as User This account acts as user (Bob)
export const getFilesByApplyStatusAsUser = async (
  account: Account,
  status = 0,
  pageIndex = 1,
  pageSize = 10
) => {
  /*return data format: {
  list: [
    { apply_id, file_id:, proposer, proposer_id, file_owner:, file_owner_id:, policy_id, hrac, start_at:, end_at, days, created_at }
    ...
  ],
  total: 300,
}
*/

  return await getFilesByStatus(
    undefined,
    account.id,
    undefined,
    undefined,
    status,
    pageIndex,
    pageSize
  );
};

//get the application status files (applying but not approved) This account acts as user (Bob), need to approved
export const getFilesPendingApprovalAsUser = async (
  account: Account,
  pageIndex = 1,
  pageSize = 10
) => {
  /*return data format: {
  list: [
    { apply_id, file_id:, proposer, proposer_id, file_owner:, file_owner_id:, policy_id, hrac, start_at:, end_at, days, created_at }
    ...
  ],
  total: 300,
}
*/

  return await getFilesByStatus(
    undefined,
    account.id,
    undefined,
    undefined,
    1,
    pageIndex,
    pageSize
  );
};

//Obtain a list of approved documents (downloadable): get the Approved success status files, So that I can use it. This account acts as user (Bob), approved
export const getApprovedFilesAsUser = async (
  account: Account,
  pageIndex = 1,
  pageSize = 10
) => {
  /*return data format: {
  list: [
    { apply_id, file_id:, proposer, proposer_id, file_owner:, file_owner_id:, policy_id, hrac, start_at:, end_at, days, created_at }
    ...
  ],
  total: 300,
}
*/

  return await getFilesByStatus(
    undefined,
    account.id,
    undefined,
    undefined,
    2,
    pageIndex,
    pageSize
  );
};

//get the Approved failed status files, So that I can not use it. This account acts as user (Bob)
export const getUnapprovedFilesAsUser = async (
  account: Account,
  pageIndex = 1,
  pageSize = 10
) => {
  /*return data format: {
  list: [
    { apply_id, file_id:, proposer, proposer_id, file_owner:, file_owner_id:, policy_id, hrac, start_at:, end_at, days, created_at }
    ...
  ],
  total: 300,
}
*/
  return await getFilesByStatus(
    undefined,
    account.id,
    undefined,
    undefined,
    3,
    pageIndex,
    pageSize
  );
};

//get files info by status This account acts as the user (Bob) or publisher (Alice)
export const getFilesByStatus = async (
  fileId?: string,
  proposerId?: string, //	Proposer's account ID
  fileOwnerId?: string, //Account ID of the file owner
  applyId?: string, //To apply for ID
  status = 1, //Application Status，0:all status 1: applying，2: approved, 3: rejected
  pageIndex = 1,
  pageSize = 10
) => {
  /*
https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E7%94%B3%E8%AF%B7%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8%E5%88%97%E8%A1%A8
return data format: {
  list: [
    { apply_id, file_id:, proposer, proposer_id, file_owner:, file_owner_id:, policy_id, policy_label, policy_label_id, hrac, start_at:, end_at, days, created_at, status }
    ...
  ],
  total: 300,
}

*/

  if (isBlank(applyId) && isBlank(proposerId) && isBlank(fileOwnerId)) {
    // Message.error(
    //   `The request parameters proposer_id, file_owner_id must be passed at least one of these fields or pass the applyId field `,
    // );
    throw new Error(
      `The proposer_id and file_owner_id parameters must be provided for at least one of these fields or the applyId field must be passed`
    );
  }

  const sendData = {
    status: status,
    paginate: {
      page: pageIndex,
      page_size: pageSize,
    },
  };

  if (!isBlank(fileId)) {
    sendData["file_id"] = fileId;
  }

  if (!isBlank(applyId)) {
    sendData["apply_id"] = applyId;
  }

  if (!isBlank(proposerId)) {
    sendData["proposer_id"] = proposerId;
  }

  if (!isBlank(fileOwnerId)) {
    sendData["file_owner_id"] = fileOwnerId;
  }

  const data = (await serverPost("/apply/list", sendData)) as object;

  if (isBlank(data)) {
    return {};
  }

  return data;
};

//get information about the current of all using policies by publiser others, the current account as Bob
export const getInUsePoliciesInfo = async (
  account: Account,
  pageIndex = 1,
  pageSize = 10
) => {
  /*
  https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E7%AD%96%E7%95%A5%E4%BF%A1%E6%81%AF%E5%88%97%E8%A1%A8  return data format: {
  list: [
    {hrac, policy_id, creator, creator_id, creator_address, consumer,consumer_id, consumer_addres, gas, tx_hash, encrypted_pk, start_at, end_at, created_at} //encrypted_pk is policy encrypted_pk
    ...
  ],
  total: 300,
  }
  */

  const data = (await getPoliciesInfo(
    undefined,
    undefined,
    account.id,
    undefined,
    pageIndex,
    pageSize
  )) as object;
  return data;
};

//get information about all published policies under the account
export const getPublishedPoliciesInfo = async (
  account: Account,
  pageIndex = 1,
  pageSize = 10
) => {
  /*
  https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E7%AD%96%E7%95%A5%E4%BF%A1%E6%81%AF%E5%88%97%E8%A1%A8
  return data format: {
  list: [
    {hrac, policy_id, creator, creator_id, creator_address, consumer,consumer_id, consumer_addres, gas, tx_hash, encrypted_pk, start_at, end_at, created_at} //encrypted_pk is policy encrypted_pk
    ...
  ],
  total: 300,
}*/

  const data = (await getPoliciesInfo(
    undefined,
    account.id,
    undefined,
    undefined,
    pageIndex,
    pageSize
  )) as object;
  return data;
};

//get policy(published) informations by policy Id
export const getPoliciesInfo = async (
  policyId?: number,
  creatorId?: string, //ID of the policy creator account
  consumerId?: string, //ID of the policy user account
  policyLabelId?: string, // label id of policy
  pageIndex = 1,
  pageSize = 10
) => {
  /*
  https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E7%AD%96%E7%95%A5%E4%BF%A1%E6%81%AF%E5%88%97%E8%A1%A8  return data format: {
  list: [
    {hrac, policy_id, creator, creator_id, creator_address, consumer,consumer_id, consumer_addres, gas, tx_hash, encrypted_pk, start_at, end_at, created_at} //encrypted_pk is policy encrypted_pk
    ...
  ],
  total: 300,
  }
  */

  const sendData = {
    paginate: {
      page: pageIndex,
      page_size: pageSize,
    },
  };

  if (!isBlank(policyId)) {
    sendData["policy_id"] = policyId; // center server policyId must be number
  }

  if (!isBlank(policyLabelId)) {
    sendData["policy_label_id"] = policyLabelId;
  }

  if (!isBlank(creatorId)) {
    sendData["creator_id"] = creatorId;
  }

  if (!isBlank(consumerId)) {
    sendData["consumer_id"] = consumerId;
  }

  const data = await serverPost("/policy/list", sendData);

  return data;
};

//calcurate publish policy server fee (nlk/tnlk): By calling calcPolicyCost
export const getPolicyTokenCost = async (
  publisher: Account,
  startDate: Date, //policy usage start date
  endDate: Date, //policy usage start date
  ursulaShares: number //URSULA_N_SHARES,
): Promise<BigNumber> => {
  const alice: Alice = await makeAlice(publisher);

  // const startDate: Date = new Date(startSeconds * 1000); //  start_at is seconds, but Date needs milliseconds
  // const endDate: Date = new Date(endSeconds * 1000); //  end_at is seconds, but Date needs milliseconds

  //return wei
  const gasWei = await calcPolicyCost(
    alice,
    startDate,
    endDate,
    ursulaShares
  );
  return gasWei;
};

//calcurate publish policy server fee (nlk/tnlk)
//you can get ether: Web3.utils.fromWei(costGasWei.toNumber().toString(), "ether" )
const calcPolicyCost = async (
  alice: Alice,
  startDate: Date, //policy usage start date
  endDate: Date, //policy usage start date
  ursulaShares: number //URSULA_N_SHARES must be great than 0
): Promise<BigNumber> => {
  if (ursulaShares <= 0) {
    throw new Error("shares must be greater than zero");
  }

  //return wei
  const value = await SubscriptionManagerAgent.getPolicyCost(
    alice.web3Provider.provider, //note: the provider must be nulink network provider
    ursulaShares,
    toEpoch(startDate),
    toEpoch(endDate)
  );

  return value;
};

export const estimatePolicyGas = async (
  publisher: Account,
  userAccountId: string, // proposer account id
  applyId: string, // Application Record id
  ursulaShares: number, //n   m of n => 3 of 5
  ursulaThreshold: number, // m
  startDate: Date, //policy usage start date
  endDate: Date, //policy usage start date
  serverFee: BigNumber, //nlk in wei
  porterUri?: string
): Promise<BigNumber> => {
  // calcPolicyEstimateGasFee
  const beingApprovedOrApproved: boolean =
    await checkFileApprovalStatusIsApprovedOrApproving(applyId);

  if (beingApprovedOrApproved) {
    throw new PolicyHasBeenActivedOnChain("Policy is currently active");
  }

  const resultInfo = await getBlockchainPolicy(
    publisher,
    userAccountId,
    applyId,
    ursulaShares,
    ursulaThreshold,
    startDate,
    endDate,
    porterUri,
    false
  );

  // //enPolicy service fee wei
  // const costServerFeeWei: BigNumber = await calcPolicyCost(
  //   resultInfo.alice,
  //   resultInfo.policyParameters.startDate,
  //   resultInfo.policyParameters.endDate,
  //   resultInfo.policyParameters.shares,
  // );

  console.log("before estimatePolicyGas approveNLK");
  const approveGasInWei: number = await estimateApproveNLKGas(
    publisher,
    BigNumber.from("10000000000000000000000000"),
    serverFee
  );

  console.log("before policy estimatePolicyGas");
  //Note that it takes time to evaluate gas, and since the transfer nlk function is called, it must be approved first
  const txHash: string = await approveNLK(
    publisher,
    BigNumber.from("10000000000000000000000000"),
    serverFee,
    false
  );
  console.log("before policy estimateCreatePolicyGas ");
  const gasInWei: BigNumber =
    await resultInfo.blockchainPolicy.estimateCreatePolicyGas(
      resultInfo.alice
    );
  console.log("end policy estimatePolicyGas wei:", gasInWei.toString());

  return gasInWei.add(approveGasInWei);
};

const getBlockchainPolicy = async (
  publisher: Account,
  userAccountId: string, // proposer account id
  applyId: string, // Application Record ID
  ursulaShares: number, //n   m of n => 3 of 5
  ursulaThreshold: number, // m
  startDate: Date,
  endDate: Date,
  porterUri?: string,
  calcUrsula = true
): Promise<{
  blockchainPolicy: BlockchainPolicy;
  strategy: Strategy;
  policyParameters: BlockchainPolicyParameters;
  alice: Alice;
  ursulas: Ursula[];
  publisherAccount: Account;
}> => {
  //https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E6%89%B9%E5%87%86%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%94%B3%E8%AF%B7
  //return {}

  porterUri = porterUri || (await getPorterUrl());

  const userInfo = (await getAccountInfo(userAccountId)) as object;
  // if(!userInfo || isBlank(userInfo))
  // {
  //   Message.error(`get user failed by user id: ${userAccountId}`);
  //   throw new Error(`get user failed by user id: ${userAccountId}`)
  // }
  // assert(userInfo && !isBlank(userInfo));
  if (!userInfo || isBlank(userInfo)) {
    throw new Error(
      `Failed to retrieve account information from the database for account ID: ${userAccountId}`
    );
  }
  // console.log("Bob account Info: ", userInfo);
  const alice: Alice = await makeAlice(publisher, porterUri);
  // Note Bob, Enrico's Encrypted PK SK is the same as Verify PK SK.  Alice verify PK can use encrypted PK.

  const bob: RemoteBob = makeRemoteBob(
    userInfo["encrypted_pk"],
    userInfo["encrypted_pk"]
  ); //userInfo["verify_pk"]);

  // console.log("Bob encrypted_pk: ", userInfo["encrypted_pk"]);
  // console.log("Bob verify_pk: ", userInfo["verify_pk"]);

  //1. get apply policy info
  //return {start_at, end_at, policy_label, policy_label_id, file_owner_id,proposer_id,file_id}
  const policyData = (await getApplyDetails(applyId)) as object;
  // assert(policyData && !isBlank(policyData));
  if (!policyData || isBlank(policyData)) {
    throw new Error(
      `Failed to retrieve policyData information from the database for apply ID: ${applyId}`
    );
  }

  //2. create policy to block chain
  // const config = await getData();
  // const porter = new Porter(porterUri);
  const label = policyData["policy_label"];
  const threshold = ursulaThreshold; //THRESHOLD
  const shares = ursulaShares; // SHARES

  // const startDate: Date = new Date();
  // const startMs: number = Date.parse(startDate.toString());
  // const endMs: number = startMs + (policyData["days"] as number) * 24 * 60 * 60 * 1000;
  // const endDate: Date = new Date(endMs); //  start_at is seconds, but Date needs milliseconds

  const policyParameters: BlockchainPolicyParameters = {
    bob: bob,
    label: label,
    threshold: threshold,
    shares: shares,
    startDate: startDate,
    endDate: endDate,
  };

  //get ursula start
  let ursulas;

  if (calcUrsula) {
    /*   try {
    ursulas = await porter.getUrsulas(shares);
  } catch (e) {
    const info = e as Object;
    if (Object.prototype.hasOwnProperty.call(info, "status") && info["status"].toString().startsWith("2")) {
      //2xx
      // console.log("businsesFlow getUrsulas info['data']", info);
      ursulas = info["data"].result.ursulas;
    } else {
      throw e;
    }
  } */

    let i = 0;
    while (i < 3) {
      try {
        ursulas = await getUrsulas(porterUri, shares);
        break;
      } catch (error) {
        //http request retry again
        i++;

        console.error("getUrsulas: ", error);
        if (i >= 3) {
          console.error(
            "Failed to retrieve Ursula information due to network issues; please try again",
            error
          );
          throw new getUrsulaError(
            "Failed to retrieve Ursula information due to network issues; please try again"
          );
        }

        await sleep(1000);
      }
    }

    // console.log("before ursulas:",ursulas);
    try {
      ursulas = ursulas.result.ursulas;
    } catch (error) {
      ursulas = ursulas.data.result.ursulas;
    }

    //Change the underline naming to small hump naming
    ursulas = humps.camelizeKeys(ursulas);

    // length 66 public string to PublicKey Object
    //now @nulink_network/nulink-ts@0.7.0 must be the version 0.7.0
    for (const ursula of ursulas) {
      ursula.encryptingKey = PublicKey.fromBytes(
        compressPublicKeyBuffer2(ursula.encryptingKey)
      );
    }

    //get ursula end
    // console.log("ursulas:",ursulas);
  }

  const strategy: Strategy | undefined =
    publisher.getAccountStrategyByStategyId(
      policyData["policy_label_id"] as string
    );
  // console.log("ApprovalUseFiles strategy", strategy);
  // assert(strategy !== undefined);
  if (!strategy || isBlank(strategy)) {
    //` get account strategy failed, label_id ${policyData["policy_label_id"]},\n When you Restore Account, You must Import account Vault data!!!`
    throw new Error(
      `The user's data version is outdated and cannot be imported. Please export the latest data to prevent data loss!`
    );
  }

  // console.log("the account address is:", publisher.address);
  // console.log("the account key is:", pwdDecrypt(publisher.encryptedKeyPair._privateKey, true));

  console.log("before createChainPolicy");
  const policy: BlockchainPolicy = await createChainPolicy(
    alice,
    policyParameters,
    strategy
  );
  console.log("after createChainPolicy");
  // "@nulink_network/nulink-ts": "^0.7.0",  must be this version

  return {
    blockchainPolicy: policy,
    strategy: strategy,
    policyParameters: policyParameters,
    alice: alice,
    ursulas: calcUrsula ? ursulas : [],
    publisherAccount: publisher,
  };
};

export const checkFileApprovalStatusIsApprovedOrApproving = async (
  applyId: string | number
): Promise<boolean> => {
  //Query whether the approval status is being approved or approving
  const data = (await getApplyDetails(applyId as string)) as any;

  if (data && [2, 4].includes(data?.status)) {
    //2: approved , 4: approving
    return true;
  }

  return false;
};

//Approval of application for use of Files, This account acts as Publisher (Alice) grant
export const approvalApplicationForUseFiles = async (
  publisher: Account,
  userAccountId: string, // proposer account id
  applyId: string, // Application Record ID
  ursulaShares: number, //n   m of n => 3 of 5
  ursulaThreshold: number, // m
  startDate: Date, //policy usage start date
  endDate: Date, //policy usage start date
  remark = "", //remark
  porterUri = "",
  //To handle whole numbers, Wei can be converted using BigNumber.from(), and Ether can be converted using ethers.utils.parseEther(). It's important to note that BigNumber.from("1.2") cannot handle decimal numbers (x.x).
  gasFeeInWei: BigNumber = BigNumber.from("-1") //must be the token of the chain (e.g. bnb), not be the nlk
) => {
  //https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E6%89%B9%E5%87%86%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%94%B3%E8%AF%B7
  //return {}

  // console.log("the account address is:", publisher.address);
  // console.log("the account key is:", pwdDecrypt(publisher.encryptedKeyPair._privateKey, true));

  const beingApprovedOrApproved: boolean =
    await checkFileApprovalStatusIsApprovedOrApproving(applyId);

  if (beingApprovedOrApproved) {
    throw new PolicyHasBeenActivedOnChain("Policy is currently active");
  }

  const resultInfo = await getBlockchainPolicy(
    publisher,
    userAccountId,
    applyId,
    ursulaShares,
    ursulaThreshold,
    startDate, //policy usage start date
    endDate, //policy usage start date
    porterUri
  );

  //Ensure that the BNB balance is greater than the GAS fee balance
  const balance: BigNumber = await getBalance(publisher.address);
  const chainConfigInfo = await getSettingsData();

  console.log(
    `the account token balance is: ${balance.toString()} wei ${
      chainConfigInfo.token_symbol
    }`
  );
  console.log(
    `the create policy gas fee is: ${gasFeeInWei.toString()} wei ${
      chainConfigInfo.token_symbol
    }`
  );

  if (!gasFeeInWei.eq(BigNumber.from("-1")) && balance.lt(gasFeeInWei)) {
    const balanceValue = Web3.utils.fromWei(balance.toString(), "ether");
    const gasValue = Web3.utils.fromWei(gasFeeInWei.toString(), "ether");
    // Message.error(
    //   `The account (${publisher.address}) balance of ${balanceValue} ether in [token] ${chainConfigInfo.token_symbol} is insufficient to publish a policy with a gas value of ${gasValue} ether`,
    // );
    console.log(
      `The account (${publisher.address}) balance of ${balanceValue} ether in [token] ${chainConfigInfo.token_symbol} is insufficient to publish a policy with a gas value of ${gasValue} ether`
    );
    throw new InsufficientBalanceError(
      `The account (${publisher.address}) balance of ${balanceValue} ether in [token] ${chainConfigInfo.token_symbol} is insufficient to publish a policy with a gas value of ${gasValue} ether`
    );
  }

  //enPolicy service fee gas wei
  const costServerFeeWei: BigNumber = await calcPolicyCost(
    resultInfo.alice,
    resultInfo.policyParameters.startDate,
    resultInfo.policyParameters.endDate,
    resultInfo.policyParameters.shares
  );

  const txHashOrEmpty: string = await approveNLK(
    publisher,
    BigNumber.from("10000000000000000000000000"),
    costServerFeeWei,
    false
  );

  // eslint-disable-next-line no-extra-boolean-cast
  console.log(!!txHashOrEmpty ? `no need approve` : `txHash: ${txHashOrEmpty}`);

  //wei can use  BigNumber.from(), ether can use ethers.utils.parseEther(), because the BigNumber.from("1.2"), the number can't not be decimals (x.x)
  //await publisher.getNLKBalance() return ethers
  //Check whether the account balance is less than the policy creation cost
  const nlkBalanceEthers: BigNumber = ethers.utils.parseEther(
    await publisher.getNLKBalance()
  );
  const costServerGasEther = Web3.utils.fromWei(
    costServerFeeWei.toString(),
    "ether"
  );

  console.log(
    `the account balance is: ${nlkBalanceEthers.toString()} ether nlk`
  );
  console.log(
    `the create policy server fee is: ${costServerGasEther.toString()} ether nlk`
  );

  //Don't forget the mint fee (service charge), so use the method lte, not le
  if (nlkBalanceEthers.lt(costServerFeeWei)) {
    // Message.error(
    //   `The account ${publisher.address} balance of ${nlkBalanceEthers} ether in [token] ${chainConfigInfo.nlk_token_symbol} is insufficient to publish policy with a value of ${costServerGasEther} ether`,
    // );
    console.log(
      `The account ${publisher.address} balance of ${nlkBalanceEthers} ether in [token] ${chainConfigInfo.nlk_token_symbol} is insufficient to publish policy with a value of ${costServerGasEther} ether`
    );
    throw new InsufficientBalanceError(
      `The account ${publisher.address} balance of ${nlkBalanceEthers} ether in [token] ${chainConfigInfo.nlk_token_symbol} is insufficient to publish policy with a value of ${costServerGasEther} ether`
    );
  }

  // "@nulink_network/nulink-ts": "^0.7.0",  must be this version
  console.log("before policy enact");
  const waitReceipt = false;

  const web3: Web3 = await getWeb3();
  const gasPrice: BigNumber = BigNumber.from(await web3.eth.getGasPrice());
  const gesLimit: BigNumber = gasFeeInWei.div(gasPrice);
  const enPolicy: EnactedPolicy = await resultInfo.blockchainPolicy.enact(
    resultInfo.ursulas,
    waitReceipt,
    gesLimit
  );
  console.log("end policy enact");
  // // Persist side-channel
  // const aliceVerifyingKey: PublicKey = alice.verifyingKey;
  // const policyEncryptingKey: PublicKey = enPolicy.policyKey;

  const encryptedTreasureMap: EncryptedTreasureMap =
    enPolicy.encryptedTreasureMap;
  const encryptedTreasureMapBytes: Uint8Array = encryptedTreasureMap.toBytes();
  //3. upload encrypt files to IPFS
  const encryptedTreasureMapIPFS = await setIPFSData(encryptedTreasureMapBytes);

  //4. call center server to save policy info
  const hrac: HRAC = enPolicy.id;

  const sendData: any = {
    account_id: publisher.id,
    apply_id: Number(applyId),
    remark: remark,
    policy: {
      hrac: fromBytesByEncoding(hrac.toBytes(), "binary"), //.toString(),
      gas: costServerFeeWei.toString(),
      tx_hash: enPolicy.txHash,
      encrypted_address: encryptedTreasureMapIPFS,
      encrypted_pk: resultInfo.strategy.strategyKeyPair._publicKey, //policy_encrypted_pk
    },
  };
  sendData["signature"] = await signUpdateServerDataMessage(
    publisher,
    sendData
  );
  //V1->V2: The background approve logic changes to: store tx_hash to a table , and then execute approve operator after listening for an on-chain event
  const data = await serverPost("/apply/approve", sendData);
  return Object.assign(
    { txHash: enPolicy.txHash, from: publisher.address },
    data || { info: "succeed" }
  );
};

//reject of application for use of Files, This account acts as Publisher (Alice) grant
export const refusalApplicationForUseFiles = async (
  publisher: Account,
  applyId: string, // Application Record ID
  remark = "" //remark
) => {
  //https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E6%8B%92%E7%BB%9D%E6%96%87%E4%BB%B6%E4%BD%BF%E7%94%A8%E7%94%B3%E8%AF%B7
  //return {}
  const sendData: any = {
    account_id: publisher.id,
    apply_id: Number(applyId),
    remark: remark,
  };

  sendData["signature"] = await signUpdateServerDataMessage(
    publisher,
    sendData
  );
  const data = await serverPost("/apply/reject", sendData);
  return data;
};

//Gets the file information associated with the policy (so the policy has been published)
export const getFilesByPolicyId = async (
  policyId: string, // filter policyLabelId
  policyPublisherId?: string, // policy publisher id, This account acts as Alice account.id
  policyUserId?: string, // policy user id,This account acts as Bob account.id
  pageIndex = 1,
  pageSize = 10
) => {
  /*
  https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E8%8E%B7%E5%8F%96%E7%AD%96%E7%95%A5%E5%85%B3%E8%81%94%E7%9A%84%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF%E5%88%97%E8%A1%A8  return data format: {
  return data format: {
  list: [
    {file_id , file_name :, owner , owner_id, address:,thumbnail:,created_at:, policy_id, policy_hrac, policy_start_at, policy_end_at}
    ...
  ],
  total: 300,
}
  */

  const sendData = {
    policy_id: policyId,
    paginate: {
      page: pageIndex,
      page_size: pageSize,
    },
  };

  if (!isBlank(policyPublisherId)) {
    sendData["creator_id"] = policyPublisherId;
  }

  if (!isBlank(policyUserId)) {
    sendData["consumer_id"] = policyUserId;
  }

  const data = await serverPost("/policy/file-detail-list", sendData);
  return data;
};

//TODO: Not currently supported
//(Revoke)Undoes published policies, the account as publisher (Alice)
//action: Cancel the policy and delete the association between the file and the policy and the application for using all files corresponding to the policy,the policy label records can not be delete
//notice: the policy must be pulished can be revoked, otherwise(the policy not published)
// revoke the apply of use files by call the api revokePermissionApplicationOfFiles
export const revokePublishedPolicies = async (
  publisher: Account,
  userAccountId: string,
  policyId: string
) => {
  //https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E6%92%A4%E9%94%80%E7%AD%96%E7%95%A5
  //return {}

  //TODO: 1. revoke the contract on blockchain
  throw new Error("Not currently supported");

  //2. center server revoke the policy info etc.
  const sendData: any = {
    account_id: publisher.id, //policy have published
    cousumer_id: userAccountId,
    policy_id: policyId,
  };

  sendData["signature"] = await signUpdateServerDataMessage(
    publisher,
    sendData
  );
  const data = await serverPost("/policy/revoke", sendData);
  return data;
};

//Get approved document content (downloadable), input parameter by call getApprovedFilesAsUser (Account) return  file content
export const getFileContentAsUser = async (
  userAccount: Account,
  policyEncryptingKey: string,
  aliceVerifyingKey: string, //note: adapter nucypher-ts ,this input parameter should be aliceEncryptedKey string
  fileIPFSAddress: string,
  encryptedTreasureMapIPFSAddress: string,
  porterUri?: string
): Promise<ArrayBuffer> => {
  //https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E6%92%A4%E9%94%80%E7%AD%96%E7%95%A5
  //return {}

  porterUri = porterUri || (await getPorterUrl());

  const bob: Bob = await makeBob(userAccount, porterUri);
  // console.log("Bob userAccount: ", userAccount);
  // console.log("porterUri: ", porterUri);
  //getFileContent from IPFS
  const fileIpfsData: Buffer = await getIPFSData(fileIPFSAddress);
  // console.log("fileIpfsData: ", fileIpfsData);
  const encryptedMessage: MessageKit = MessageKit.fromBytes(fileIpfsData);
  const encryptedTreasureMapIpfsData: Buffer = await getIPFSData(
    encryptedTreasureMapIPFSAddress
  );
  // console.log("encryptedTreasureMapIpfsData: ", encryptedTreasureMapIpfsData);
  const encryptedTreasureMap: EncryptedTreasureMap =
    EncryptedTreasureMap.fromBytes(encryptedTreasureMapIpfsData);
  // console.log("encryptedMessage: ", encryptedMessage);
  // console.log("encryptedTreasureMap: ", encryptedTreasureMap);
  // console.log("policyEncryptingKey: ", policyEncryptingKey);
  // console.log("compressed policyEncryptingKey: ", compressPublicKeyBuffer(policyEncryptingKey));
  // console.log("aliceVerifyingKey: ", aliceVerifyingKey);
  // console.log("compressed aliceVerifyingKey: ", compressPublicKeyBuffer(aliceVerifyingKey));

  // console.log("before retrievedMessage");

  const retrievedMessage = await bob.retrieveAndDecrypt(
    PublicKey.fromBytes(compressPublicKeyBuffer(policyEncryptingKey)),
    PublicKey.fromBytes(compressPublicKeyBuffer(aliceVerifyingKey)),
    [encryptedMessage],
    encryptedTreasureMap
  );

  // console.log("retrievedMessage: ", retrievedMessage);

  return retrievedMessage[0].buffer;

  //const bobPlaintext = Buffer.from(retrievedMessage[0].buffer).toString('binary');
  // const bobPlaintext = fromBytes(retrievedMessage[0]);
  // console.log("bobPlaintext: ", bobPlaintext);
};

//Get approved document content (downloadable), input parameter by call  getApprovedFilesAsUser (Account) return  file content
export const getFileContentByFileIdAsUser = async (
  userAccount: Account,
  fileId: string
): Promise<ArrayBuffer> => {
  //get file info
  const data = (await getFileDetails(fileId, userAccount.id)) as object;

  assert(data && !isBlank(data));

  const policyEncryptingKey = data["policy_encrypted_pk"];
  const aliceVerifyingKey = data["alice_verify_pk"];
  const fileIPFSAddress = data["file_ipfs_address"];
  const encryptedTreasureMapIPFSAddress =
    data["encrypted_treasure_map_ipfs_address"];

  return getFileContentAsUser(
    userAccount,
    policyEncryptingKey,
    aliceVerifyingKey,
    fileIPFSAddress,
    encryptedTreasureMapIPFSAddress
  );
};

//file uploader as the file owner to download file  return file content
export const getFileContentByFileIdAsPublisher = async (
  userAccount: Account,
  fileId: string
): Promise<ArrayBuffer> => {
  //get file info
  const data = (await getFileDetails(fileId, userAccount.id)) as object;

  assert(data && !isBlank(data));

  const policyEncryptingKey = data["policy_encrypted_pk"] || "";
  const aliceVerifyingKey = data["alice_verify_pk"] || ""; //account.encryptedKeyPair._publicKey
  const fileIPFSAddress = data["file_ipfs_address"];

  //Firstcheck whether the file belongs to the user
  if (
    userAccount.encryptedKeyPair._publicKey.toLowerCase() !==
    aliceVerifyingKey.toLowerCase()
  ) {
    throw new Error(
      "Illegal request: you must be the file uploader to decrypt"
    ); // data recovery failed
  }

  let strategyPrivatekey: string | null = null;
  //find the strategy private key for decrypt
  const strategys: Strategy[] = userAccount.getAllStrategy();
  for (let index = 0; index < strategys.length; index++) {
    const strategy = strategys[index];
    if (
      strategy.strategyKeyPair._publicKey.toLowerCase() ===
      policyEncryptingKey.toLowerCase()
    ) {
      strategyPrivatekey = strategy.strategyKeyPair._privateKey;
      break;
    }
  }

  if (!strategyPrivatekey) {
    throw new Error("Failed to obtain strategy information"); // data recovery failed
  }

  //getFileContent from IPFS
  const fileIpfsData: Buffer = await getIPFSData(fileIPFSAddress);
  // console.log("fileIpfsData: ", fileIpfsData);
  const encryptedMessage: MessageKit = MessageKit.fromBytes(fileIpfsData);

  const privateKeyString = pwdDecrypt(strategyPrivatekey as string, true);
  // console.log("makeBob BobEncrypedPrivateKey: ",privateKeyString);

  // notice: bacause the encryptedMessage.decrypt( get by MessageKit) use the SecretKey import from nucypher-ts, so you  must be use the nucypher-ts's SecretKey PublicKey , not use the nucypher-core's SecretKey PublicKey (wasm code) to avoid the nucypher_core_wasm_bg.js Error: expected instance of e

  const secretKey = NucypherTsSecretKey.fromBytes(
    privateKeyBuffer(privateKeyString)
  );
  const plainText: Uint8Array = encryptedMessage.decrypt(secretKey);

  return plainText.buffer;
};

//TODO: get ApplyInfo by apply id
export const getApplyDetails = async (applyId: string) => {
  //https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E7%94%B3%E8%AF%B7%E8%AF%A6%E6%83%85
  //return  { policy_label, policy_label_id,start_at,end_at, days, status }

  const sendData = {
    apply_id: Number(applyId),
  };

  try {
    const data = (await serverPost("/apply/detail", sendData)) as object;
    return data;
  } catch (error: any) {
    if (error?.data?.code === 4006) {
      //"apply does not exist"
      return null;
    }

    console.error(
      `getApplyDetails error apply id ${applyId}`,
      error?.data?.msg || error?.message || error
    );
    throw error;
  }
};

//get file detail info, include apply file info, file info, about policy info
//fileUserAccountId: This parameter passes the file finder when the file consumer is not known, fileUserAccountId should be passed the current account Id
export const getFileDetails = async (
  fileId: string,
  fileUserAccountId: string
) => {
  /*
  https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E6%96%87%E4%BB%B6%E8%AF%A6%E6%83%85
  status: 0 => not apply (Initial state), 1=> Application in progress, 2 =>approved, 3=> rejected
  return {
          file_id:,file_name:,thumbnail:,file_created_at:,apply_id:,status:,apply_start_at:,apply_end_at:,apply_created_at:,
          policy_id:,hrac:,creator:,creator_id:,consumer:,consumer_id:,gas:,tx_hash:,policy_created_at:,
          file_ipfs_address:,policy_encrypted_pk:,encrypted_treasure_map_ipfs_address:,alice_verify_pk
        } 
*/
  const sendData = {
    file_id: fileId,
    consumer_id: fileUserAccountId,
  };

  const data = await serverPost("/file/detail", sendData);
  return data;
};

//Get Policy Label infos
export const getPolicyLabelInfos = async (
  publisherAccount: Account,
  pageIndex = 1,
  pageSize = 10
) => {
  //publisherAccount : the creater of label
  /*
    https://github.com/NuLink-network/nulink-node/blob/main/API.md#%E7%AD%96%E7%95%A5-label-%E5%88%97%E8%A1%A8    return data format: {
      list: [
        {label, label_id:, creator, creator_id, create_at}
        ...
      ],
      total: 300,
    }
*/
  const sendData = {
    account_id: publisherAccount.id,
    paginate: {
      page: pageIndex,
      page_size: pageSize,
    },
  };

  const data = await serverPost("/label/list", sendData);
  return data;
};

//Get Policy Label's infos by address of account
export const getPolicyLabelInfosByAddr = async (
  accountAddress: string
) => {
  //accountAddress : string
  /*
    return data format: 
       [ { 'policy_label_id': '', 'policy_label':'', 'policy_label_index': '', 'policy_encrypted_pk':'', }, ...] 

       //policy_encrypted_pk: This is the encrypted_pk passed in the /file/create-policy-and-upload API interface
  */

  return Account.getStrategyInfosFromServerByAddr(accountAddress);
};

//Get Policy Label infos
export const getAccountAllofPolicyLabelIds = async (
  publisherAccount: Account
) => {
  //publisherAccount : the creater of label
  /*
    return data format: {
      "label_ids": [ label_id1, label_id2,label_id3, ...]
    }
  */

  return getPolicyLabelIdsByAccountId(publisherAccount.id);
};

//Get Policy Label's Id infos
export const getPolicyLabelIdsByAccountId = async (
  accountId: string
) => {
  //accountId : string
  /*
    return data format: {
      "label_ids": [ label_id1, label_id2,label_id3, ...]
    }
*/
  const sendData = {
    creator_id: accountId,
  };

  const data = await serverPost("/label/label-ids", sendData);
  return data;
};