<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <button id="create">第一步：创建钱包</button>
    <button id="run_next">第二步：继续运行用例</button>

    <div id="text" class="text-box">这是一段文本显示框</div>
  </body>
</html>
<script src="./nulink-sdk.js"></script>

<script>
  console.log('【---NUSDK----】', NUSDK);
  document.getElementById('text').textContent = NUSDK;
  // console.log('【---NUSDK.getPolicysGasFee----】', NUSDK.getPolicysGasFee)
  // console.log('【---NUSDK.Buffer----】', NUSDK.Buffer)
  // console.log('【---NUSDK.BigNumber----】', NUSDK.BigNumber)
  // //console.log('【---Web3----】', Web3)

  // ----------------------全局变量区 start ------------------------
  const password = '1';
  let nuLinkHDWallet;
  let mnemonic;
  let accountAlice;

  const sleep = async (ms) => {
    return new Promise((resolve) => setTimeout(resolve, ms));
  };

  const _create = async () => {
    try {
      return await NUSDK.createWallet(password);
    } catch (error) {
      console.error('【Create Wallet Error】', error);
      return null;
    }
  };
  // ----------------------全局变量区 end ------------------------

  const test1 = async () => {
    const dataCallback = {
      setData: NUSDK.setIPFSData,
      getData: NUSDK.getIPFSData
    };

    //Set the external storage used by the Pre process to IPFS (for example, encrypted files uploaded by users will be stored in this storage, and users can customize the storage).
    NUSDK.StorageManager.setDataCallback(dataCallback);

    //we need set Project ID: differentiate the sources of data from different applications. 
    // which requires application to Nulink official.
    await initClientId("xxxxxxx-xxxxx-xxxxxx");

    bExistAccount = await NUSDK.existDefaultAccount()
    console.log("existDefaultAccount: ", bExistAccount);
    //nuLinkHDWallet = await NUSDK.restoreHDWallet(mnemonic, password);
    try {
      console.log('--------------------- before load wallet: -------------------');
      nuLinkHDWallet = await NUSDK.loadWallet(password);
    } catch (error) {
      console.log('--------------------- before _create wallet: -------------------');
      nuLinkHDWallet = await _create();
    }
    console.log('--------------------- nuLinkHDWallet: -------------------', nuLinkHDWallet);

    //  = await nuLinkHDWallet.getMnemonic(password);
    // console.log("--------------------- mnemonic: -------------------", mnemonic);

    //debugger;
    console.assert(!NUSDK.isBlank(nuLinkHDWallet), 'nuLinkHDWallet create or load failed');

    //also, We can verify whether the user's password is correct
    let correct = await NUSDK.verifyPassword(password);

    console.assert(correct, 'password is error');

    let hasAnAccountInLocal = await NUSDK.existDefaultAccount();

    console.assert(correct, 'default account is not exist');

    accountAlice = await NUSDK.getWalletDefaultAccount(password);

    console.assert(!NUSDK.isBlank(accountAlice), 'get default account Failed: accountAlice');

    const mnemonic = await nuLinkHDWallet.getMnemonic(password);

    console.log('【账户对象】:', nuLinkHDWallet);
    console.log('【助记词】:', mnemonic);
    document.getElementById('text').textContent = mnemonic;
    console.log('【Account Alice】:', accountAlice);
    console.log('【Get Account Manager】', nuLinkHDWallet.getAccountManager());
    console.log('accountAlice address', accountAlice.address);
    console.log('accountAlice addressIndex', accountAlice.addressIndex);
    console.log('accountAlice publicKey', accountAlice.encryptedKeyPair._publicKey);
    console.log('accountAlice privateKey', NUSDK.decrypt(accountAlice.encryptedKeyPair._privateKey, true));

    console.log(
      '请注意： --------------------- 运行这段代码需要账户上有至少0.1个TBNB, 至少 200个TNLK, 合约当前用的V9版本, 由于测试anroid环境代码对应的存储使用的是内存，所以每次刷新页面账户会变化，需要重新转币和TNLK-----------------'
    );
    console.log(
      '请注意： --------------------- 运行这段代码需要账户上有至少0.1个TBNB, 至少 200个TNLK, 合约当前用的V9版本, 由于测试anroid环境代码对应的存储使用的是内存，所以每次刷新页面账户会变化，需要重新转币和TNLK -----------------'
    );
    console.log(
      '请注意： --------------------- 运行这段代码需要账户上有至少0.1个TBNB, 至少 200个TNLK, 合约当前用的V9版本, 由于测试anroid环境代码对应的存储使用的是内存，所以每次刷新页面账户会变化，需要重新转币和TNLK -----------------'
    );
    console.log('请注意： --------------------- 账户地址： ', accountAlice.address);

    //debugger;
  };

  const test2 = async () => {
    // Note: We only support one account currently.

    //Now we can encrypt and upload a file for others to apply for download

    //1. read a file
    const plainText =
      '# encoding=utf-8\n\nimport requests\nimport json\nfrom config.web3_provider import W3\n\n\'\'\'\n    Aaveçå¬åçº¦ååºçäºä»¶å¹¶æ¥æ¾å¯æ¸ ç®è´¦æ·\n\'\'\'\n\n\nclass ListenEvent:\n    def __init__(self, chain_type, scan_address):\n        self.web3 = W3(chain_type=chain_type, num=3)\n        self.chain_type = chain_type\n        self.scan_address = scan_address\n        self.event_topic = "0xc6a898309e823ee50bac64e45ca8adba6690e99e7841c45d754e2a38e9019d9b"\n        self.api = "https://api.aurorascan.dev/api"\n        self.pool_contract = self.web3.load_contract("AAVEPool", self.scan_address)\n        self.variable_debt_token_list = [\n            ["variable-debt-usdc", "0x8b225BF698eFd7fA4A9E3FB10424711739304ACa"],\n            ["variable-debt-usdt", "0xc0D1Be1C87B56b72Db03800726AAB7e61AE9AaC7"],\n            ["variable-debt-wnear", "0xaa0E01C05a6361fe8aD037A4b142f633e418B251"],\n            ["variable-debt-weth", "0x541996252ECcF5047671302CaaFf25b4312d482e"],\n            ["variable-debt-dai", "0x1c2E8486e2aF6B168a7985Dcec3309780bEb5F25"],\n            ["variable-debt-wbtc", "0x90eCe2301214b2B86cB77326232e2b6D4b373d7B"]\n        ]\n        self.collateral_token_list = [\n            ["aUsdc", "0x0a88079323d2cCf5f83014a5351058553439499C"],\n            ["aUsdt", "0xD55f46Df9C67297619CD6b254167F5Ed1F34998e"],\n            ["aWnear", "0x6f610C3Ff9e64625ae29C2DA7663Ec100A9433bE"],\n            ["aWeth", "0x935ef78719d55b3a8a53d0ac9494a94658843953"],\n            ["aDai", "0xf4d853d5b100A739B03584b0C2840D136b16DDB8"],\n            ["aWbtc", "0x8047CC5397Fdc885ab2EE1DaEE277237ceB4AE50"]\n        ]\n        self.LIQUIDATION_CLOSE_FACTOR_PERCENT = 5000\n\n    def listen_event(self, from_block, to_block):\n        print("from_block %s, to_block %s" % (from_block, to_block))\n        params = {\n            "module": "logs",\n            "action": "getLogs",\n            "fromBlock": from_block,\n            "toBlock": to_block,\n            "address": self.scan_address,\n            "topic0": self.event_topic\n        }\n        res = requests.get(url=self.api, params=params)\n        if res.status_code == 200:\n            content = json.loads(res.content)\n            if content["status"] == "1":\n                log_info_list = content["result"]\n                for log in log_info_list:\n                    topics = log["topics"]\n                    tx_hash = log["transactionHash"]\n                    log_data = log["data"]\n                    reserve = "0x" + topics[1][26:]\n                    user = "0x" + self.web3.get_data_params(log_data, 0)[24:]\n                    user_data = self.pool_contract.functions.getUserAccountData(\n                        self.web3.w3.toChecksumAddress(user)).call()\n                    health = int(user_data[-1]) / (10 ** 18)\n                    need_liquidation = True if health < 1 else False\n                    amount = self.web3.w3.toInt(hexstr=self.web3.get_data_params(log_data, 1))\n                    borrow_rate_mode = self.web3.w3.toInt(hexstr=self.web3.get_data_params(log_data, 2))\n                    borrow_rate = self.web3.w3.toInt(hexstr=self.web3.get_data_params(log_data, 3))\n                    on_behalf_of = "0x" + topics[2][26:]\n                    print("-> tx_hash", tx_hash)\n                    print("     -> reserve", reserve)\n                    print("     -> user", user)\n                    print("     -> onBehalfOf", on_behalf_of)\n                    print("     -> amount", amount)\n                    print("     -> borrowRateMode", borrow_rate_mode)\n                    print("     -> borrowRate", borrow_rate)\n                    print("     -> borrowRate", borrow_rate)\n                    print("     -> health", health)\n                    print("     -> needLiquidation", need_liquidation)\n\n    def get_user_liquidation_info(self, user):\n        print("***** user debt info *****")\n        for debt_token_info in self.variable_debt_token_list:\n            debt_token_name, debt_token = debt_token_info\n            debt_token_contract = self.web3.get_erc20_contract(self.web3.w3.toChecksumAddress(debt_token))\n            token_amount = debt_token_contract.functions.balanceOf(\n                self.web3.w3.toChecksumAddress(user)\n            ).call()\n            max_liquidatable_debt = (token_amount * self.LIQUIDATION_CLOSE_FACTOR_PERCENT + 1e4/2) / 1e4 if token_amount > 0 else 0\n            print(debt_token_name, token_amount, max_liquidatable_debt)\n        print("***** user collateral info *****")\n        for collateral_token_info in self.collateral_token_list:\n            collateral_token_name, collateral_token = collateral_token_info\n            collateral_token_contract = self.web3.get_erc20_contract(self.web3.w3.toChecksumAddress(collateral_token))\n            token_amount = collateral_token_contract.functions.balanceOf(\n                self.web3.w3.toChecksumAddress(user)\n            ).call()\n            print(collateral_token_name, token_amount)\n\n\n\nif __name__ == "__main__":\n    listen_event = ListenEvent("AURORA", "0xa0bC830Ad82D2EAe0bCFd1D6987664A3D9264aFA")\n    # to_block = listen_event.web3.get_latest_block_num()\n    # listen_event.listen_event("62001019", to_block)\n    listen_event.get_user_liquidation_info("0xee0eb9eff81e70b06e8fe181b4a0db924816bc54")\n\n';
    const enc = new TextEncoder(); // always utf-8
    const historyContent /* : Uint8Array */ = enc.encode(plainText);

    //1.Alice upload file
    const fileList /*: DataInfo[]*/ = [
      {
        label: `history-${NUSDK.nanoid()}.pdf`,
        dataArrayBuffer: historyContent.buffer,
        mimetype: "application/pdf",
      },
      {
        label: `history1-${NUSDK.nanoid()}.pdf`,
        dataArrayBuffer: historyContent.buffer,
        mimetype: "application/pdf",
      },
      {
        label: `history2-${NUSDK.nanoid()}.pdf`,
        dataArrayBuffer: historyContent.buffer,
        mimetype: "application/pdf",
      },
      {
        label: `history3-${NUSDK.nanoid()}.pdf`,
        dataArrayBuffer: historyContent.buffer,
        mimetype: "application/pdf",
      },
      {
        label: `history4-${NUSDK.nanoid()}.pdf`,
        dataArrayBuffer: historyContent.buffer,
        mimetype: "application/pdf",
      }
    ];

    //2. Alice encrypt and update a file to the ipfs network
    await NUSDK.uploadDataByCreatePolicy(accountAlice, NUSDK.DataCategory.History, fileList);

    //3. We can get the files just uploaded
    const resultList = await NUSDK.getUploadedData(accountAlice, undefined, 1, 1000);

    /*
        {
            list: [
            {file_id, file_name:, owner, owner_id, address:,thumbnail:,create_at}
            ...
            ],
            total: 300,
        }
        */

    console.log('resultList: ', resultList);
    console.log('resultList["total"]>0 ', resultList['total'] > 0);
    console.assert(resultList && resultList['total'] > 0, 'default account is not exist');

    let fileIndex = -1;
    for (let index = 0; index < resultList['list'].length; index++) {
      const element = resultList['list'][index];
      if (element['file_name'] === fileList[0]['label']) {
        fileIndex = index;
        break;
      }
    }
    console.assert(fileIndex >= 0, "can't find the files just uploaded");
    const uploadFileInfo = resultList['list'][fileIndex];

    /*   console.log('uploadFileInfo["file_name"] ', uploadFileInfo["file_name"]);
        console.log('fileList[0]["name"] ', fileList[0]["name"]);
        console.log('equal1: ', uploadFileInfo["file_name"] === fileList[0]["name"]);
        console.log('uploadFileInfo["owner_id"] ', uploadFileInfo["owner_id"] );
        console.log('accountAlice.id ', accountAlice.id);
        console.log('equal2: ', uploadFileInfo["owner_id"] === accountAlice.id); */

    console.assert(uploadFileInfo['owner_id'] === accountAlice.id, 'uploadFileInfo["owner_id"] !== accountAlice.id ');

    const numReqFiles = 10;
    // ............................................
    //
    //Bob find the file on Internet
    const bobAccountId2AccountMap = {};
    const accountBobs /*: Account[]*/ = [];
    const accountManager /*: AccountManager */ = nuLinkHDWallet.getAccountManager();
    for (let index = 0; index < numReqFiles; index++) {
      const accountBob /*: Account */ = await accountManager.createAccount(`Bob_${index}`);
      // call the createAccountIfNotExist method for add user account to the center server for decouple
      await NUSDK.createAccountIfNotExist(accountBob);
      accountBobs.push(accountBob);
      bobAccountId2AccountMap[accountBob.id] = accountBob;
    }

    let applyFileId /*: string */ = '';
    for (let index = 0; index < accountBobs.length; index++) {
      const accountBob = accountBobs[index];

      //Bob finds the file Alice has just uploaded
      const findFileResultList = await NUSDK.getOtherShareData(
        accountBob,
        undefined,
        false,
        undefined,
        undefined,
        undefined,
        1,
        100
      ); /*as object*/
      /*
            {
                list: [
                {file_id, file_name:, owner, owner_id, address:,thumbnail:,create_at}
                ...
                ],
                total: 300,
            }
            */

      console.assert(
        findFileResultList && findFileResultList['total'] > 0,
        '! findFileResultList || findFileResultList["total"] == 0'
      );

      let fileIndex2 = -1;
      for (let index = 0; index < findFileResultList['list'].length; index++) {
        const element = findFileResultList['list'][index];
        if (element['file_name'] === fileList[0]['label']) {
          fileIndex2 = index;
          break;
        }
      }
      console.assert(fileIndex2 >= 0, 'fileIndex2 < 0');

      const findFileInfo = findFileResultList['list'][fileIndex2];
      console.assert(findFileInfo['owner_id'] === accountAlice.id, 'findFileInfo["owner_id"] !== accountAlice.id ');

      applyFileId = findFileInfo['file_id'];

      //get file details
      const fileDetails = await NUSDK.getDataDetails(applyFileId, accountBob.id); /*as object*/
      /*
            {
                    file_id:,file_name:,thumbnail:,file_created_at:,apply_id:,status:,apply_start_at:,apply_end_at:,apply_created_at:,
                    policy_id:,hrac:,creator:,creator_id:,consumer:,consumer_id:,gas:,tx_hash:,policy_created_at:,
                    file_ipfs_address:,policy_encrypted_pk:,encrypted_treasure_map_ipfs_address:,alice_verify_pk
            } 
        */
      // console.assert(fileDetails["creator_id"] === accountAlice.id, 'fileDetails["creator_id"] != accountAlice.id');
      console.assert(fileDetails['file_id'] === applyFileId, 'fileDetails["file_id"] != applyFileId');
      console.assert(parseInt(fileDetails['status']) === 0, 'fileDetails["status"] != 0'); //Is not to apply for

      //Bob requests permission to use the file for 7 days
      try {
        await NUSDK.applyForDataUsagePermission(applyFileId, accountBob, 7);
      } catch (e) {
        console.log(`bob_${index} apply file failed`, e);
        console.assert(false, `bob_${index} apply file failed`);
      }
    }

    //Alice receives Bob's file usage request
    const filesNeedToApprovedResultList2 = await NUSDK.getDataPendingApprovalAsPublisher(accountAlice, 1, 1000);
    /*return data format: {
            list: [
            { apply_id, file_id:, proposer, proposer_id, file_owner:, file_owner_id:, policy_id, hrac, start_at:, end_at, days,  created_at }
            ...
            ],
            total: 300,
        }
        */

    console.assert(
      filesNeedToApprovedResultList2 && filesNeedToApprovedResultList2['total'] > 0,
      '!filesNeedToApprovedResultList2 || filesNeedToApprovedResultList2["total"] == 0'
    );

    const fileIndexs /*: number[] */ = []; //Array(numReqFiles).fill(-1);
    for (let index = 0; index < filesNeedToApprovedResultList2['list'].length; index++) {
      const element = filesNeedToApprovedResultList2['list'][index];
      if (element['file_id'] === applyFileId) {
        fileIndexs.push(index);
        console.assert(element['file_owner_id'] === accountAlice.id, 'element["file_owner_id"] !== accountAlice.id');
      }
    }
    console.assert(
      fileIndexs.length >= 0 && fileIndexs.length == numReqFiles,
      'fileIndexs.length == 0 || fileIndexs.length !== numReqFiles '
    );

    //At this point Alice approves Bob's file usage request, Due to on-chain approval of Bob's request, we first evaluate gas and service fees
    const startDates /*: Date[] */ = [];
    const endDates /*: Date[] */ = [];
    const startMss /*: number[] */ = [];
    const endMss /*: number[] */ = [];
    const ursulaShares /*: number[] */ = [];
    const ursulaThresholds /*: number[] */ = [];
    const accountBobIds /*: string[] */ = [];
    const applyIds /*: string[] */ = [];
    for (let index = 0; index < fileIndexs.length; index++) {
      const fileIndex = fileIndexs[index];
      const needToApprovedFileInfo = filesNeedToApprovedResultList2['list'][fileIndex];
      //1. Alice calc server fee (wei): the nulink token tnlk/nlk

      const startMs /*: number */ =
        (Math.floor(new Date().getTime() / 1000) - new Date().getTimezoneOffset() * 60) * 1000;
      const startDate /*: Date */ = new Date(startMs); //  start_at is seconds, but Date needs milliseconds

      const endMs /*: number */ = startMs + needToApprovedFileInfo['days'] /*as number*/ * 24 * 60 * 60 * 1000;
      const endDate /*: Date */ = new Date(endMs); //  start_at is seconds, but Date needs milliseconds
      const bobAccountId = needToApprovedFileInfo['proposer_id'];
      accountBobIds.push(bobAccountId);
      startDates.push(startDate);
      endDates.push(endDate);
      startMss.push(startMs);
      endMss.push(endMs);
      ursulaShares.push(2);
      ursulaThresholds.push(1);
      applyIds.push(needToApprovedFileInfo['apply_id']);
    }

    const serverFeeNLKInWei /*: BigNumber */ = await NUSDK.getPolicysTokenCost(
      accountAlice,
      startDates,
      endDates,
      ursulaShares
    );

    // const serverValue = Web3.utils.fromWei(serverFeeNLKInWei.toString(), "ether");
    // console.log("server nlk fee  ether is:", serverValue);

    //2. Alice calc gas fee (wei): the chain of bsc test token
    const gasInfo /*: GasInfo */ = await NUSDK.getPolicysGasFee(
      accountBobIds,
      applyIds,
      ursulaShares,
      ursulaThresholds,
      startMss.map((startMs) => startMs / 1000),
      endMss.map((endMs) => endMs / 1000),
      NUSDK.BigNumber.from(serverFeeNLKInWei)
    );

    const aliceApprovedfilesListLast = await NUSDK.getApprovedDataAsPublisher(accountAlice, 1, 1000);

    //Note: Please make sure that the account has sufficient tnlk and bsc testnet tokens before this, otherwise the approval will fail
    //Alice approves Bob's application for file usage. Whenever Alice approves a file request, an on-chain policy is created
    await NUSDK.approvalApplicationsForUseData(
      accountAlice,
      accountBobIds,
      applyIds,
      ursulaShares,
      ursulaThresholds,
      startDates,
      endDates,
      '', //remark
      '', //porterUri
      gasInfo.gasFee
    );

    // eslint-disable-next-line no-debugger
    // debugger;

    //You need to wait for a while for the on-chain transaction to be confirmed and for the backend to listen for the "approve" event.
    await sleep(20000); //20 seconds

    let aliceApprovedfilesList /*: any */ = null;
    do {
      await sleep(10000); //10 seconds
      //Alice, as the publisher of the file, obtains the list of files that she has successfully approved
      aliceApprovedfilesList = await NUSDK.getApprovedDataAsPublisher(accountAlice, 1, 1000);
      /*return data format: {
            list: [
                { apply_id, file_id:, proposer, proposer_id, file_owner:, file_owner_id:, policy_id, hrac, start_at:, end_at, created_at }
                ...
            ],
            total: 300,
            }
        */
    } while (!aliceApprovedfilesList || aliceApprovedfilesList['total'] <= aliceApprovedfilesListLast['total']);

    // eslint-disable-next-line no-debugger
    // debugger;

    console.assert(
      aliceApprovedfilesList && aliceApprovedfilesList['total'] > 0,
      '!aliceApprovedfilesList || aliceApprovedfilesList["total"] == 0'
    );

    //Record this policy ID and account Bob for future use.
    let policyId;
    let accountBob;
    const fileIndex2s /*: number[] */ = []; //Array(numReqFiles).fill(-1);
    for (let index = 0; index < aliceApprovedfilesList['list'].length; index++) {
      const element = aliceApprovedfilesList['list'][index];
      if (element['file_id'] === applyFileId) {
        fileIndex2s.push(index);

        console.assert(element['file_owner_id'] === accountAlice.id, 'element["file_owner_id"] !== accountAlice.id');

        const _policyId = element['policy_id'];
        policyId = _policyId;
        //console.log(`index_${index} file policy Id: ${policyId}`)
        const accountBobId = element['proposer_id'];
        const _accountBob = bobAccountId2AccountMap[accountBobId];
        accountBob = _accountBob;
        //Bob finds out that his application has been approved by Alice. Bob now has permission to view the contents of the file
        const bobBeApprovedfilesList = await NUSDK.getApprovedDataAsUser(_accountBob, 1, 1000);
        /*return data format: {
                                    list: [
                                        { apply_id, file_id:, proposer, proposer_id, file_owner:, file_owner_id:, policy_id, hrac, start_at:, end_at, created_at }
                                        ...
                                    ],
                                    total: 300,
                                    }
            */

        console.assert(
          bobBeApprovedfilesList && bobBeApprovedfilesList['total'] > 0,
          '!bobBeApprovedfilesList || bobBeApprovedfilesList.total == 0'
        );

        let fileIndex6 = -1;
        for (let index = 0; index < bobBeApprovedfilesList['list'].length; index++) {
          const element = bobBeApprovedfilesList['list'][index];
          if (element['file_id'] === applyFileId) {
            fileIndex6 = index;
            break;
          }
        }
        console.assert(fileIndex6 >= 0, 'fileIndex6 < 0');

        const bobBeApprovedfilesInfo = bobBeApprovedfilesList['list'][fileIndex6];
        console.assert(
          bobBeApprovedfilesInfo['file_owner_id'] === accountAlice.id,
          'bobBeApprovedfilesInfo.file_owner_id !== accountAlice.id'
        );
        const policyId2 = bobBeApprovedfilesInfo['policy_id'];
        console.assert(policyId2 === _policyId, 'ppolicyId2 !== policyId');

        //Finally, Bob gets the contents of the file
        const arrayBuffer /*: ArrayBuffer */ = await NUSDK.getDataContentByDataIdAsUser(
          _accountBob,
          bobBeApprovedfilesInfo['file_id']
        );
        const fileContent /*: string */ = NUSDK.Buffer.from(arrayBuffer).toString();
        console.log('fileContent: ', fileContent);
        console.log('plainText: ', plainText);
        console.assert(fileContent === plainText, 'fileContent !== plainText');

        //finish
      }
    }

    console.assert(fileIndex2s.length > 0, 'fileIndex2s.length = 0');

    //Alice upload file to exist policy

    const plainText2 = 'This is a philosophy book content';
    const historyContent2 /*: Uint8Array */ = enc.encode(plainText2);

    //1.upload file by create policy
    const fileList2 /*: DataInfo[] */ = [
      {
        label: `philosophy-${NUSDK.nanoid()}.pdf`,
        dataArrayBuffer: historyContent2.buffer,
        mimetype: "application/pdf",
      }
    ];

    const fileIds = await NUSDK.uploadDataBySelectPolicy(
      accountAlice,
      NUSDK.DataCategory.Philosophy,
      fileList2,
      policyId
    );

    //Bob get new upload file content
    const arrayBuffer2 /*: ArrayBuffer */ = await NUSDK.getDataContentByDataIdAsUser(accountBob, fileIds[0]);
    const fileContent2 /*: string*/ = NUSDK.Buffer.from(arrayBuffer2).toString();
    console.log('fileContent2: ', fileContent2);
    console.log('plainText2: ', plainText2);
    console.assert(fileContent2 === plainText2, 'fileContent2 !== plainText2');

    //you can get all status files for mine apply: The files I applied for
    //status 0: all status, include:  applying，approved, rejected
    const data = await NUSDK.getDataByStatus(undefined, accountBob.id, undefined, undefined, 0, 1, 1000);
    /*
            return data format: {
            list: [
                { apply_id, file_id:, proposer, proposer_id, file_owner:, file_owner_id:, policy_id, hrac, start_at:, end_at, days, created_at, status }
                ...
            ],
            total: 300,
            }
        */

    console.assert(data && !NUSDK.isBlank(data) && data['total'] > 0, 'data is blank or total is 0');

    console.log('finish');
  };

  document.querySelector('#create').addEventListener('click', test1);
  document.querySelector('#run_next').addEventListener('click', test2);
</script>
